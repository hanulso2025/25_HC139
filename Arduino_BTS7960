/*
 * 2륜 구동 로봇 PID 위치 제어
 * - Arduino Mega 2560 + BTS7960 모터 드라이버
 * - 17PPR 증분형 엔코더 (2채널), 4배 분주(Quadrature x4)
 * - 감속비 1/21
 * - 시리얼 명령어: 'forward', 'backward'
 */

 #include <Arduino.h>

 // ======== 로봇 파라미터 (MM 단위 거리 설정) ========
 const float PPR                         = 95.0;      // 엔코더 PPR
 const float GEAR_RATIO                  = 200.0;      // 감속비
 const float ENCODER_DECODER_FACTOR      = 4.0;       // 디코딩 배수 (Quadrature x4)
 const float WHEEL_DIAMETER_MM           = 72.0;      // 바퀴 직경 (mm)
 const float WHEEL_CIRCUMFERENCE_MM      = WHEEL_DIAMETER_MM * PI;
 // MM당 펄스수 = (PPR * 감속비 * 디코딩 배수) / 바퀴 둘레(mm)
 const float PULSES_PER_MM               = (PPR * GEAR_RATIO * ENCODER_DECODER_FACTOR) / WHEEL_CIRCUMFERENCE_MM;
 // ================================================
 
 // 모터 드라이버 핀 설정 (BTS7960)
 // 왼쪽 모터 BTS7960 핀
 const int L_REN    = 11;    // 왼쪽 모터 정방향 Enable 핀
 const int L_LEN    = 10;    // 왼쪽 모터 역방향 Enable 핀
 const int L_RPWM   = 13;   // 왼쪽 모터 정방향 PWM
 const int L_LPWM   = 12;   // 왼쪽 모터 역방향 PWM
 // 오른쪽 모터 BTS7960 핀
 const int R_REN    = 7;    // 오른쪽 모터 정방향 Enable 핀
 const int R_LEN    = 6;    // 오른쪽 모터 역방향 Enable 핀
 const int R_RPWM   = 9;    // 오른쪽 모터 정방향 PWM
 const int R_LPWM   = 8;    // 오른쪽 모터 역방향 PWM
 
 // 엔코더 핀 설정 (인터럽트 핀)
 const int LEFT_ENCODER_A  = 18;
 const int LEFT_ENCODER_B  = 19;
 const int RIGHT_ENCODER_A = 20;
 const int RIGHT_ENCODER_B = 21;
 
 // 엔코더 카운트 변수
 volatile long leftEncoderCount  = 0;
 volatile long rightEncoderCount = 0;
 
 // 목표 위치 (펄스)
 volatile long leftTargetPosition  = 0;
 volatile long rightTargetPosition = 0;
 
 // PID 제어 관련 상수
 const unsigned long CONTROL_INTERVAL = 10; // 10ms
 float Kp = 0.05;
 float Ki = 0;
 float Kd = 0;
 
 // PID 내부 변수
 long leftPrevError  = 0;
 long rightPrevError = 0;
 long leftIntegral   = 0;
 long rightIntegral  = 0;
 int  leftPWM        = 0;
 int  rightPWM       = 0;
 
 // 이동 거리 설정 (mm)
 long moveDistanceMM = 1000; // 원하는 이동 거리 (mm)
 

 // 로봇 상태
 boolean isMoving   = false; // 움직이고있는지
 boolean isForward  = true;  // 전진중인지. 전진이면 True, 후진이면 False
 
 // 시리얼 통신용 변수
 String inputString = "";
 boolean stringComplete = false;

 
 unsigned long prevTime = 0;
 
 void setup() {
   Serial.begin(115200);
   inputString.reserve(200);
 
   pinMode(L_REN, OUTPUT);
   pinMode(L_LEN, OUTPUT);
   pinMode(L_RPWM, OUTPUT);
   pinMode(L_LPWM, OUTPUT);
   pinMode(R_REN, OUTPUT);
   pinMode(R_LEN, OUTPUT);
   pinMode(R_RPWM, OUTPUT);
   pinMode(R_LPWM, OUTPUT);
 
   // 모터 정지 및 Enable 활성화
   digitalWrite(L_REN, HIGH);  // BTS7960은 Enable을 HIGH로 설정해야 작동
   digitalWrite(L_LEN, HIGH);
   digitalWrite(R_REN, HIGH);
   digitalWrite(R_LEN, HIGH);
   analogWrite(L_RPWM, 0);
   analogWrite(L_LPWM, 0);
   analogWrite(R_RPWM, 0);
   analogWrite(R_LPWM, 0);
 
   pinMode(LEFT_ENCODER_A, INPUT_PULLUP);
   pinMode(LEFT_ENCODER_B, INPUT_PULLUP);
   pinMode(RIGHT_ENCODER_A, INPUT_PULLUP);
   pinMode(RIGHT_ENCODER_B, INPUT_PULLUP);
 
   attachInterrupt(digitalPinToInterrupt(LEFT_ENCODER_A), leftEncoderA_ISR, CHANGE);
   attachInterrupt(digitalPinToInterrupt(LEFT_ENCODER_B), leftEncoderB_ISR, CHANGE);
   attachInterrupt(digitalPinToInterrupt(RIGHT_ENCODER_A), rightEncoderA_ISR, CHANGE);
   attachInterrupt(digitalPinToInterrupt(RIGHT_ENCODER_B), rightEncoderB_ISR, CHANGE);
 
   Serial.println("2륜 구동 로봇 PID 위치 제어 시스템");
   Serial.println("명령어: 'forward' - 앞으로 이동, 'backward' - 뒤로 이동");
   Serial.println();
   leftEncoderCount = 0;
   rightEncoderCount = 0;
   prevTime = millis();
 }
 
 void loop() {
   if (stringComplete) {
     if (inputString.indexOf("forward") >= 0){
        startMoving(true);

     }   
     else if (inputString.indexOf("backward") >= 0) {
      startMoving(false);

     }
     inputString = "";
     stringComplete = false;
   }
 
   unsigned long currentTime = millis(); 
   
   if (currentTime - prevTime >= CONTROL_INTERVAL) {  //내가 설정한 PID 제어 주기마다 실행하기 위한 조건문
     if (isMoving) { //움직이는 중이면
       updatePID();
       // 왼쪽 OR 오른쪽이 목표값과 EDGE 차이가 100개 미만으로 나면 정지
       if (abs(leftTargetPosition  - leftEncoderCount) < 100 ||
           abs(rightTargetPosition - rightEncoderCount) < 100) {
         stopMotors(); //실제로 모터 정지하는 함수
         isMoving = false;
         Serial.println("목표 위치에 도달했습니다.");
       }
     }
 
     if (isMoving) {
       Serial.print("leftEncoderCount:"); Serial.print(leftEncoderCount);
       Serial.print(", rightEncoderCount:"); Serial.print(rightEncoderCount);
       Serial.print(", leftTargetPos:"); Serial.print(leftTargetPosition);
       Serial.print(", rightTargetPos:"); Serial.println(rightTargetPosition);
       Serial.print("왼쪽 PWM: "); Serial.print(leftPWM);
       Serial.print(", 오른쪽 PWM: "); Serial.println(rightPWM);
     }
     prevTime = currentTime;
   }
 }
 
 //시리얼 이벤트 들어오면 loop문 돌때마다 loop문 다돌고 자동으로 호출되는 함수 (키보드 입력받는 애)
 void serialEvent() {
   while (Serial.available()) {
     char inChar = (char)Serial.read();
     inputString += inChar;
     if (inChar == '\n') stringComplete = true;
   }
 }
 
 void startMoving(boolean forward) { //Serial 입력 들어올때마다 한 번 씩만 호출되는 함수
   isForward = forward;
   long pulseOffset = (long)(moveDistanceMM * PULSES_PER_MM); //위에서 내가 설정한 거리를 edge수로 계산하여 저장
   if (forward) {
     leftEncoderCount = 0;
     rightEncoderCount = 0;
     leftTargetPosition  = leftEncoderCount  - pulseOffset; //check
     rightTargetPosition = rightEncoderCount + pulseOffset; //
     Serial.println("앞으로 이동합니다.");
   } else {
     leftEncoderCount = -pulseOffset;
     rightEncoderCount = pulseOffset;
     leftTargetPosition  = leftEncoderCount  + pulseOffset;
     rightTargetPosition = rightEncoderCount - pulseOffset;
     Serial.println("뒤로 이동합니다.");
   }
   leftPrevError = rightPrevError = 0;
   leftIntegral = rightIntegral = 0;
   isMoving = true;
   
   // BTS7960에서는 방향에 따라 다른 PWM 핀과 Enable 핀 설정
   if (forward) {
     // 정방향 사용, 역방향 비활성화
     analogWrite(L_RPWM, 0);  // 역방향 PWM은 0으로
     analogWrite(R_LPWM, 0);  // 
     
     // Enable 핀 설정
     digitalWrite(L_LEN, HIGH);  // 정방향 Enable 활성화
     digitalWrite(L_REN, LOW);   // 역방향 Enable 비활성화
     digitalWrite(R_REN, HIGH);
     digitalWrite(R_LEN, LOW);
   } else {
     // 역방향 사용, 정방향 비활성화
     analogWrite(L_LPWM, 0);  // 정방향 PWM은 0으로
     analogWrite(R_RPWM, 0);
     
     // Enable 핀 설정
     digitalWrite(L_LEN, LOW);   // 정방향 Enable 비활성화
     digitalWrite(L_REN, HIGH);  // 역방향 Enable 활성화
     digitalWrite(R_REN, LOW);
     digitalWrite(R_LEN, HIGH);
   }
 }
 
 void updatePID() {
  long leftError,rightError;
   //전진시
   if(isForward==true)  leftError = leftEncoderCount - leftTargetPosition;
   //후진시
   else  leftError  = leftTargetPosition - leftEncoderCount  ;
   leftIntegral   += leftError * CONTROL_INTERVAL;
   leftIntegral    = constrain(leftIntegral, -100, 100);
   long leftDeriv  = (leftError - leftPrevError) / CONTROL_INTERVAL;
   float leftOut   = Kp*leftError + Ki*leftIntegral + Kd*leftDeriv;
   leftPWM = constrain((int)leftOut, 0, 100);
 
   // 왼쪽 모터: BTS7960에서는 방향에 따라 다른 PWM 핀에 값 적용
   // 주의: RPWM과 LPWM이 동시에 0초과가 되면 안됨
   if (isForward) {
     // 정방향일 때는 RPWM만 사용하고 LPWM은 반드시 0
     analogWrite(L_RPWM, 0);
     analogWrite(L_LPWM, leftPWM);
     
   } else {
     // 역방향일 때는 LPWM만 사용하고 RPWM은 반드시 0
     analogWrite(L_LPWM, 0);
     analogWrite(L_RPWM, leftPWM);
   }
   
   if(isForward==true)  rightError = rightTargetPosition - rightEncoderCount;
   else  rightError = rightEncoderCount - rightTargetPosition;
   rightIntegral  += rightError * CONTROL_INTERVAL;
   rightIntegral   = constrain(rightIntegral, -100, 100);
   long rightDeriv = (rightError - rightPrevError) / CONTROL_INTERVAL;
   float rightOut  = Kp*rightError + Ki*rightIntegral + Kd*rightDeriv;
   rightPWM = constrain((int)rightOut, 0, 100);

   // 주의: RPWM과 LPWM이 동시에 0초과가 되면 안됨
   if (isForward) {
     // 정방향일 때는 RPWM만 사용하고 LPWM은 반드시 0
     analogWrite(R_LPWM, 0);
     analogWrite(R_RPWM, rightPWM);
     
   } else {
     // 역방향일 때는 LPWM만 사용하고 RPWM은 반드시 0
     analogWrite(R_RPWM, 0);
     analogWrite(R_LPWM, rightPWM);
   }
 
   leftPrevError  = leftError;
   rightPrevError = rightError;
 }
 
 void stopMotors() {
   // BTS7960에서는 모든 PWM 핀을 0으로 설정하여 정지
   analogWrite(L_RPWM, 0);
   analogWrite(L_LPWM, 0);
   analogWrite(R_RPWM, 0);
   analogWrite(R_LPWM, 0);
   
   // 안전을 위해 모든 Enable 핀을 우선 활성화 상태로 유지
   digitalWrite(L_REN, HIGH);
   digitalWrite(L_LEN, HIGH);
   digitalWrite(R_REN, HIGH);
   digitalWrite(R_LEN, HIGH);
   
   delay(50);
   
   // 완전 정지를 위해 필요 시 Enable 핀을 LOW로 설정할 수도 있음
   // digitalWrite(L_REN, LOW);
   // digitalWrite(L_LEN, LOW);
   // digitalWrite(R_REN, LOW);
   // digitalWrite(R_LEN, LOW);
 }
 
 // 왼쪽 엔코더 A상 인터럽트 서비스 루틴
 void leftEncoderA_ISR() {
   // A상과 B상의 현재 상태 읽기
   bool A_val = digitalRead(LEFT_ENCODER_A);
   bool B_val = digitalRead(LEFT_ENCODER_B);
   
   // 엔코더 카운트 업데이트 (A와 B의 위상 차이를 이용한 방향 감지)
   // A상이 rising edge일 때
   if (A_val == HIGH) {
     // B가 LOW면 시계 방향 (증가)
     if (B_val == LOW) {
       leftEncoderCount++;
     } 
     // B가 HIGH면 반시계 방향 (감소)
     else {
       leftEncoderCount--;
     }
   }
   // A상이 falling edge일 때
   else {
     // B가 HIGH면 시계 방향 (증가)
     if (B_val == HIGH) {
       leftEncoderCount++;
     } 
     // B가 LOW면 반시계 방향 (감소)
     else {
       leftEncoderCount--;
     }
   }
 }
 
 // 왼쪽 엔코더 B상 인터럽트 서비스 루틴
 void leftEncoderB_ISR() {
   // A상과 B상의 현재 상태 읽기
   bool A_val = digitalRead(LEFT_ENCODER_A);
   bool B_val = digitalRead(LEFT_ENCODER_B);
   
   // 엔코더 카운트 업데이트 (A와 B의 위상 차이를 이용한 방향 감지)
   // B상이 rising edge일 때
   if (B_val == HIGH) {
     // A가 HIGH면 시계 방향 (증가)
     if (A_val == HIGH) {
       leftEncoderCount++;
     } 
     // A가 LOW면 반시계 방향 (감소)
     else {
       leftEncoderCount--;
     }
   }
   // B상이 falling edge일 때
   else {
     // A가 LOW면 시계 방향 (증가)
     if (A_val == LOW) {
       leftEncoderCount++;
     } 
     // A가 HIGH면 반시계 방향 (감소)
     else {
       leftEncoderCount--;
     }
   }
 }
 
 // 오른쪽 엔코더 A상 인터럽트 서비스 루틴
 void rightEncoderA_ISR() {
   // A상과 B상의 현재 상태 읽기
   bool A_val = digitalRead(RIGHT_ENCODER_A);
   bool B_val = digitalRead(RIGHT_ENCODER_B);
   
   // 엔코더 카운트 업데이트 (A와 B의 위상 차이를 이용한 방향 감지)
   // A상이 rising edge일 때
   if (A_val == HIGH) {
     // B가 LOW면 시계 방향 (증가)
     if (B_val == LOW) {
       rightEncoderCount++;
     } 
     // B가 HIGH면 반시계 방향 (감소)
     else {
       rightEncoderCount--;
     }
   }
   // A상이 falling edge일 때
   else {
     // B가 HIGH면 시계 방향 (증가)
     if (B_val == HIGH) {
       rightEncoderCount++;
     } 
     // B가 LOW면 반시계 방향 (감소)
     else {
       rightEncoderCount--;
     }
   }
 }
 
 // 오른쪽 엔코더 B상 인터럽트 서비스 루틴
 void rightEncoderB_ISR() {
   // A상과 B상의 현재 상태 읽기
   bool A_val = digitalRead(RIGHT_ENCODER_A);
   bool B_val = digitalRead(RIGHT_ENCODER_B);
   
   // 엔코더 카운트 업데이트 (A와 B의 위상 차이를 이용한 방향 감지)
   // B상이 rising edge일 때
   if (B_val == HIGH) {
     // A가 HIGH면 시계 방향 (증가)
     if (A_val == HIGH) {
       rightEncoderCount++;
     } 
     // A가 LOW면 반시계 방향 (감소)
     else {
       rightEncoderCount--;
     }
   }
   // B상이 falling edge일 때
   else {
     // A가 LOW면 시계 방향 (증가)
     if (A_val == LOW) {
       rightEncoderCount++;
     } 
     // A가 HIGH면 반시계 방향 (감소)
     else {
       rightEncoderCount--;
     }
   }
 }