/*
 * 2륜 구동 로봇 PID 위치 제어
 * - Arduino Mega 2560 + L298N 모터 드라이버
 * - 17PPR 증분형 엔코더 (2채널), 4배 분주(Quadrature x4)
 * - 감속비 1/21
 * - 시리얼 명령어: 'forward', 'backward'
 */

 #include <Arduino.h>

 // ======== 로봇 파라미터 (MM 단위 거리 설정) ========
 const float PPR                         = 17.0;      // 엔코더 PPR
 const float GEAR_RATIO                  = 21.0;      // 감속비
 const float ENCODER_DECODER_FACTOR      = 4.0;       // 디코딩 배수 (Quadrature x4)
 const float WHEEL_DIAMETER_MM           = 72.0;      // 바퀴 직경 (mm)
 const float WHEEL_CIRCUMFERENCE_MM      = WHEEL_DIAMETER_MM * PI;
 // MM당 펄스수 = (PPR * 감속비 * 디코딩 배수) / 바퀴 둘레(mm)
 const float PULSES_PER_MM               = (PPR * GEAR_RATIO * ENCODER_DECODER_FACTOR) / WHEEL_CIRCUMFERENCE_MM;
 // ================================================
 
 // 모터 드라이버 핀 설정 (L298N)
 const int L_ENA = 9;    // 왼쪽 모터 Enable/PWM 핀
 const int L_IN1 = 10;   // 왼쪽 모터 방향 제어 1
 const int L_IN2 = 11;   // 왼쪽 모터 방향 제어 2
 const int R_ENB = 8;    // 오른쪽 모터 Enable/PWM 핀
 const int R_IN3 = 6;    // 오른쪽 모터 방향 제어 1
 const int R_IN4 = 7;    // 오른쪽 모터 방향 제어 2
 
 // 엔코더 핀 설정 (인터럽트 핀)
 const int LEFT_ENCODER_A  = 2;
 const int LEFT_ENCODER_B  = 3;
 const int RIGHT_ENCODER_A = 18;
 const int RIGHT_ENCODER_B = 19;
 
 // 엔코더 카운트 변수
 volatile long leftEncoderCount  = 0;
 volatile long rightEncoderCount = 0;
 
 // 목표 위치 (펄스)
 volatile long leftTargetPosition  = 0;
 volatile long rightTargetPosition = 0;
 
 // PID 제어 관련 상수
 const unsigned long CONTROL_INTERVAL = 10; // 10ms
 float Kp = 0.05;
 float Ki = 0;
 float Kd = 0;
 
 // PID 내부 변수
 long leftPrevError  = 0;
 long rightPrevError = 0;
 long leftIntegral   = 0;
 long rightIntegral  = 0;
 int  leftPWM        = 0;
 int  rightPWM       = 0;
 
 // 이동 거리 설정 (mm)
 long moveDistanceMM = 1000; // 원하는 이동 거리 (mm)
 

 // 로봇 상태
 boolean isMoving   = false;
 boolean isForward  = true;
 
 // 시리얼 통신용 변수
 String inputString = "";
 boolean stringComplete = false;

 
 unsigned long prevTime = 0;
 
 void setup() {
   Serial.begin(115200);
   inputString.reserve(200);
 
   pinMode(L_ENA, OUTPUT);
   pinMode(L_IN1, OUTPUT);
   pinMode(L_IN2, OUTPUT);
   pinMode(R_ENB, OUTPUT);
   pinMode(R_IN3, OUTPUT);
   pinMode(R_IN4, OUTPUT);
 
   // 모터 정지
   digitalWrite(L_IN1, LOW);
   digitalWrite(L_IN2, LOW);
   digitalWrite(R_IN3, LOW);
   digitalWrite(R_IN4, LOW);
   analogWrite(L_ENA, 0);
   analogWrite(R_ENB, 0);
 
   pinMode(LEFT_ENCODER_A, INPUT_PULLUP);
   pinMode(LEFT_ENCODER_B, INPUT_PULLUP);
   pinMode(RIGHT_ENCODER_A, INPUT_PULLUP);
   pinMode(RIGHT_ENCODER_B, INPUT_PULLUP);
 
   attachInterrupt(digitalPinToInterrupt(LEFT_ENCODER_A), leftEncoderA_ISR, CHANGE);
   attachInterrupt(digitalPinToInterrupt(LEFT_ENCODER_B), leftEncoderB_ISR, CHANGE);
   attachInterrupt(digitalPinToInterrupt(RIGHT_ENCODER_A), rightEncoderA_ISR, CHANGE);
   attachInterrupt(digitalPinToInterrupt(RIGHT_ENCODER_B), rightEncoderB_ISR, CHANGE);
 
   Serial.println("2륜 구동 로봇 PID 위치 제어 시스템");
   Serial.println("명령어: 'forward' - 앞으로 이동, 'backward' - 뒤로 이동");
   Serial.println();
   leftEncoderCount = 0;
   rightEncoderCount = 0;
   prevTime = millis();
 }
 
 void loop() {
   if (stringComplete) {
     if (inputString.indexOf("forward") >= 0){
        startMoving(true);

     }   
     else if (inputString.indexOf("backward") >= 0) {
      startMoving(false);

     }
     inputString = "";
     stringComplete = false;
   }
 
   unsigned long currentTime = millis();
   if (currentTime - prevTime >= CONTROL_INTERVAL) {
     if (isMoving) {
       updatePID();
       if (abs(leftTargetPosition  - leftEncoderCount) < 100 &&
           abs(rightTargetPosition - rightEncoderCount) < 100) {
         stopMotors();
         isMoving = false;
         Serial.println("목표 위치에 도달했습니다.");
       }
     }
 
     if (isMoving) {
       Serial.print("leftEncoderCount:"); Serial.print(leftEncoderCount);
       Serial.print(", rightEncoderCount:"); Serial.print(rightEncoderCount);
       Serial.print(", leftTargetPos:"); Serial.print(leftTargetPosition);
       Serial.print(", rightTargetPos:"); Serial.println(rightTargetPosition);
       Serial.print("왼쪽 PWM: "); Serial.print(leftPWM);
       Serial.print(", 오른쪽 PWM: "); Serial.println(rightPWM);
     }
     prevTime = currentTime;
   }
 }
 
 void serialEvent() {
   while (Serial.available()) {
     char inChar = (char)Serial.read();
     inputString += inChar;
     if (inChar == '\n') stringComplete = true;
   }
 }
 
 void startMoving(boolean forward) {
   isForward = forward;
   long pulseOffset = (long)(moveDistanceMM * PULSES_PER_MM);
   if (forward) {
     leftTargetPosition  = leftEncoderCount  + pulseOffset; //check
     rightTargetPosition = rightEncoderCount - pulseOffset; //
     Serial.println("앞으로 이동합니다.");
   } else {
     leftTargetPosition  = leftEncoderCount  - pulseOffset;
     rightTargetPosition = rightEncoderCount + pulseOffset;
     Serial.println("뒤로 이동합니다.");
   }
   leftPrevError = rightPrevError = 0;
   leftIntegral = rightIntegral = 0;
   isMoving = true;
   if (forward) {
     digitalWrite(L_IN1, HIGH); digitalWrite(L_IN2, LOW);
     digitalWrite(R_IN3, HIGH); digitalWrite(R_IN4, LOW);
   } else {
     digitalWrite(L_IN1, LOW);  digitalWrite(L_IN2, HIGH);
     digitalWrite(R_IN3, LOW);  digitalWrite(R_IN4, HIGH);
   }
 }
 
 void updatePID() {
  long leftError,rightError;
   if(isForward==true)  leftError = leftTargetPosition  - leftEncoderCount;
   else  leftError  = leftEncoderCount - leftTargetPosition;
   leftIntegral   += leftError * CONTROL_INTERVAL;
   leftIntegral    = constrain(leftIntegral, -100, 100);
   long leftDeriv  = (leftError - leftPrevError) / CONTROL_INTERVAL;
   float leftOut   = Kp*leftError + Ki*leftIntegral + Kd*leftDeriv;
   leftPWM        = constrain((int)leftOut, 0, 60);
   analogWrite(L_ENA, leftPWM);
   
   if(isForward==true)  rightError = rightEncoderCount-rightTargetPosition;
   else  rightError = rightTargetPosition - rightEncoderCount;
   rightIntegral  += rightError * CONTROL_INTERVAL;
   rightIntegral   = constrain(rightIntegral, -100, 100);
   long rightDeriv = (rightError - rightPrevError) / CONTROL_INTERVAL;
   float rightOut  = Kp*rightError + Ki*rightIntegral + Kd*rightDeriv;
   rightPWM       = constrain((int)rightOut, 0, 65);
   analogWrite(R_ENB, rightPWM);
 
   leftPrevError  = leftError;
   rightPrevError = rightError;
 }
 
 void stopMotors() {
   analogWrite(L_ENA, 0);
   analogWrite(R_ENB, 0);
   digitalWrite(L_IN1, HIGH); digitalWrite(L_IN2, HIGH);
   digitalWrite(R_IN3, HIGH); digitalWrite(R_IN4, HIGH);
   delay(50);
   digitalWrite(L_IN1, LOW); digitalWrite(L_IN2, LOW);
   digitalWrite(R_IN3, LOW); digitalWrite(R_IN4, LOW);
 }
 
 // ISR 생략 (원본 그대로 적용)
 
 
 // 왼쪽 엔코더 A상 인터럽트 서비스 루틴
 void leftEncoderA_ISR() {
   // A상과 B상의 현재 상태 읽기
   bool A_val = digitalRead(LEFT_ENCODER_A);
   bool B_val = digitalRead(LEFT_ENCODER_B);
   
   // 엔코더 카운트 업데이트 (A와 B의 위상 차이를 이용한 방향 감지)
   // A상이 rising edge일 때
   if (A_val == HIGH) {
     // B가 LOW면 시계 방향 (증가)
     if (B_val == LOW) {
       leftEncoderCount++;
     } 
     // B가 HIGH면 반시계 방향 (감소)
     else {
       leftEncoderCount--;
     }
   }
   // A상이 falling edge일 때
   else {
     // B가 HIGH면 시계 방향 (증가)
     if (B_val == HIGH) {
       leftEncoderCount++;
     } 
     // B가 LOW면 반시계 방향 (감소)
     else {
       leftEncoderCount--;
     }
   }
 }
 
 // 왼쪽 엔코더 B상 인터럽트 서비스 루틴
 void leftEncoderB_ISR() {
   // A상과 B상의 현재 상태 읽기
   bool A_val = digitalRead(LEFT_ENCODER_A);
   bool B_val = digitalRead(LEFT_ENCODER_B);
   
   // 엔코더 카운트 업데이트 (A와 B의 위상 차이를 이용한 방향 감지)
   // B상이 rising edge일 때
   if (B_val == HIGH) {
     // A가 HIGH면 시계 방향 (증가)
     if (A_val == HIGH) {
       leftEncoderCount++;
     } 
     // A가 LOW면 반시계 방향 (감소)
     else {
       leftEncoderCount--;
     }
   }
   // B상이 falling edge일 때
   else {
     // A가 LOW면 시계 방향 (증가)
     if (A_val == LOW) {
       leftEncoderCount++;
     } 
     // A가 HIGH면 반시계 방향 (감소)
     else {
       leftEncoderCount--;
     }
   }
 }
 
 // 오른쪽 엔코더 A상 인터럽트 서비스 루틴
 void rightEncoderA_ISR() {
   // A상과 B상의 현재 상태 읽기
   bool A_val = digitalRead(RIGHT_ENCODER_A);
   bool B_val = digitalRead(RIGHT_ENCODER_B);
   
   // 엔코더 카운트 업데이트 (A와 B의 위상 차이를 이용한 방향 감지)
   // A상이 rising edge일 때
   if (A_val == HIGH) {
     // B가 LOW면 시계 방향 (증가)
     if (B_val == LOW) {
       rightEncoderCount++;
     } 
     // B가 HIGH면 반시계 방향 (감소)
     else {
       rightEncoderCount--;
     }
   }
   // A상이 falling edge일 때
   else {
     // B가 HIGH면 시계 방향 (증가)
     if (B_val == HIGH) {
       rightEncoderCount++;
     } 
     // B가 LOW면 반시계 방향 (감소)
     else {
       rightEncoderCount--;
     }
   }
 }
 
 // 오른쪽 엔코더 B상 인터럽트 서비스 루틴
 void rightEncoderB_ISR() {
   // A상과 B상의 현재 상태 읽기
   bool A_val = digitalRead(RIGHT_ENCODER_A);
   bool B_val = digitalRead(RIGHT_ENCODER_B);
   
   // 엔코더 카운트 업데이트 (A와 B의 위상 차이를 이용한 방향 감지)
   // B상이 rising edge일 때
   if (B_val == HIGH) {
     // A가 HIGH면 시계 방향 (증가)
     if (A_val == HIGH) {
       rightEncoderCount++;
     } 
     // A가 LOW면 반시계 방향 (감소)
     else {
       rightEncoderCount--;
     }
   }
   // B상이 falling edge일 때
   else {
     // A가 LOW면 시계 방향 (증가)
     if (A_val == LOW) {
       rightEncoderCount++;
     } 
     // A가 HIGH면 반시계 방향 (감소)
     else {
       rightEncoderCount--;
     }
   }
 }